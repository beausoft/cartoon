<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>贝塞尔曲线测试</title>
</head>
<body>
    <canvas id="canvas" width="800" height="450"></canvas>
    <script>
        var canvas = document.getElementById("canvas");
        var width = canvas.width, height = canvas.height;
        var ctx = canvas.getContext('2d');
        
        function Point(x, y) {
            this.x = x;
            this.y = y;

            this.sub = function(point) {
                return new Point(this.x - point.x, this.y - point.y);
            }

            this.add = function(point) {
                return new Point(this.x + point.x, this.y + point.y);
            }

            this.scale = function(num) {
                return new Point(this.x * num, this.y * num);
            }

            this.clone = function() {
                return new Point(this.x, this.y);
            }
        }

        function randomColor() {
            return 'rgb( ' +  ( Math.random() * 255 >> 0 ) + ',' + ( Math.random() * 255 >> 0 ) + ',' + ( Math.random() * 255 >> 0 ) + ' )';
        }

        // 绘制线段。sp起始点， ep结束点
        function lineSegment(sp, ep) {
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#696969';
            ctx.beginPath();
            ctx.moveTo(sp.x, sp.y);
            ctx.lineTo(ep.x,ep.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(sp.x,sp.y,3,0,2*Math.PI);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(ep.x,ep.y,3,0,2*Math.PI);
            ctx.stroke();
        }

        function secondOrderBezierCurve(t, p0, p1, p2, p3) {
            // 使用API绘制曲线
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
            ctx.stroke();
            ctx.closePath();
            // 计算目标点
            var q0 = p1.sub(p0).scale(t).add(p0);
            var q1 = p2.sub(p1).scale(t).add(p1);
            var q2 = p3.sub(p2).scale(t).add(p2);
            var r0 = q1.sub(q0).scale(t).add(q0);
            var r1 = q2.sub(q1).scale(t).add(q1);
            var b = r1.sub(r0).scale(t).add(r0);
            // 绘制控制点线段
            lineSegment(p0, p1);
            lineSegment(p1, p2);
            lineSegment(p2, p3);
            
            lineSegment(q0, q1);
            lineSegment(q1, q2);
            lineSegment(r0, r1);
            // 使用API绘制当前t所在的曲线
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(p0.x, p0.y);
            ctx.bezierCurveTo(q0.x, q0.y, r0.x, r0.y, b.x, b.y);
            ctx.stroke();
            ctx.closePath();
            // 轨迹球
            ctx.beginPath();
            ctx.arc(b.x, b.y, 3, 0, 2*Math.PI);
            ctx.fillStyle = '#1572b5';
            ctx.fill();
            ctx.closePath();
        }

        var a_p0 = new Point(122, 247);
        var a_p1 = new Point(128, 66);  // to (130, 145)
        var a_p2 = new Point(260, 95);  // to (276, 154)
        var a_p3 = new Point(279, 255);

        var b_p0 = new Point(279, 255);
        var b_p1 = new Point(287, 357); // to (280, 358)
        var b_p2 = new Point(120, 389); // to (122, 376)
        var b_p3 = new Point(122, 247);

        var kernel = new Point(257, 272);
        var isKernel = true;

        function Schedule(duration) {
            this.duration = duration;
            this.startTime = 0;
            this.running = false;

            this.tracks = [];

            this.start = function() {
                if(!this.running) {
                    this.startTime = Date.now();
                    this.running = true;
                }
            }

            this.stop = function() {
                this.startTime = 0;
                this.running = false;
                for(var i = 0; i < this.tracks.length; i++) {
                    var track = this.tracks[i];
                    track.fn.call(this, 0.0);
                    track.finished = false;
                }
            }

            this.add = function(start, end, fn) {
                this.tracks.push({
                    start: start,
                    end: end,
                    fn: fn,
                    finished: false
                });
            }

            this.update = function() {
                if(this.running) {
                    var t = Date.now() - this.startTime;
                    if(t > this.duration) {
                        t = this.duration;
                    }
                    for(var i = 0; i < this.tracks.length; i++) {
                        var track = this.tracks[i];
                        if(track.start <= t && track.end > t) {
                            track.fn.call(this, (t - track.start) / (track.end - track.start));
                        } else if(track.end <= t && !track.finished) {
                            track.fn.call(this, 1.0);
                            track.finished = true;
                        }
                    }
                    if(t === this.duration) {
                        this.stop();
                    }
                }
            }

        }

        function closeEye(alpha) {
            if(this.running) {
                a_p1.x = (130 - 128) * alpha + 128;
                a_p1.y = (145 - 66) * alpha + 66;
                a_p2.x = (276 - 260) * alpha + 260;
                a_p2.y = (154 - 95) * alpha + 95;

                b_p1.x = (280 - 287) * alpha + 287;
                b_p1.y = (358 - 357) * alpha + 357;
                b_p2.x = (122 - 120) * alpha + 120;
                b_p2.y = (376 - 389) * alpha + 389;

                if(alpha === 1.0) {
                    isKernel = false;
                }
            }
        }

        function openEye(alpha) {
            if(this.running) {
                a_p1.x = (128 - 130) * alpha + 130;
                a_p1.y = (66 - 145) * alpha + 145;
                a_p2.x = (260 - 276) * alpha + 276;
                a_p2.y = (95 - 154) * alpha + 154;
                if(alpha === 1.0) {
                    isKernel = true;
                }
            }
        }

        var schedule = new Schedule(3000);
        schedule.add(0, 30, closeEye);
        schedule.add(100, 130, openEye);
        schedule.add(200, 230, closeEye);
        schedule.add(230, 260, openEye);
        schedule.add(3000, 3000, function() {
            if(!this.running) {
                this.start();
            }
        });
        schedule.start();

        function animloop(timestamp) {
            schedule.update();
            var t = timestamp % 5000 / 5000;
            ctx.save();
            // 清除背景
            ctx.rect(0,0, width, height);
            ctx.fillStyle="#ffffff";
            ctx.fill();
            
            secondOrderBezierCurve(t, a_p0, a_p1, a_p2, a_p3);
            secondOrderBezierCurve(t, b_p0, b_p1, b_p2, b_p3);

            var offset = new Point(200, 0);
            var c_a_p0 = new Point(a_p0.x, a_p3.y).add(offset);
            var c_a_p1 = new Point(a_p1.x, a_p2.y).add(offset);
            var c_a_p2 = new Point(a_p2.x, a_p1.y).add(offset);
            var c_a_p3 = new Point(a_p3.x, a_p0.y).add(offset);
            secondOrderBezierCurve(t, c_a_p0, c_a_p1, c_a_p2, c_a_p3);
            var c_b_p0 = new Point(b_p0.x, b_p3.y).add(offset);
            var c_b_p1 = new Point(b_p1.x, b_p2.y).add(offset);
            var c_b_p2 = new Point(b_p2.x, b_p1.y).add(offset);
            var c_b_p3 = new Point(b_p3.x, b_p0.y).add(offset);
            secondOrderBezierCurve(t, c_b_p0, c_b_p1, c_b_p2, c_b_p3);

            if(isKernel) {
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(kernel.x, kernel.y, 12, 0, 2*Math.PI)
                ctx.fill();
                ctx.closePath();

                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(a_p3.x - kernel.x + c_b_p3.x, kernel.y, 12, 0, 2*Math.PI)
                ctx.fill();
                ctx.closePath();
            }
            // 动画循环
            ctx.restore();
            requestAnimationFrame(animloop);
        }
        requestAnimationFrame(animloop);
    </script>
</body>
</html>
